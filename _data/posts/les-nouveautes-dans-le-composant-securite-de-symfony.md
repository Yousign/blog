---
tags: []
title: Les nouveaut√©s dans le composant S√©curit√© de¬†Symfony
excerpt: Chaque nouvelle version de Symfony apporte son lot de nouveaut√©s. Mais la
  version 5.1 propose un nouveau syst√®me d‚Äôauthentification et ce syst√®me change le
  comportement interne de la s√©curit√© Symfony, pour le rendre extensible et plus compr√©hensible.
coverImage: https://ys-storage-public-blogtech-content-bucket.s3.eu-west-3.amazonaws.com/maj-security-symfony
  copie 5@2x.png
date: 2020-12-31T23:00:00Z
authors:
- _data/authors/Sma√Øne.md

---
Chaque nouvelle version de Symfony apporte son lot de nouveaut√©s. ü•∞ Mais la version 5.1 propose un nouveau syst√®me d‚Äôauthentification et ce syst√®me change le comportement interne de la s√©curit√© Symfony, pour le rendre extensible et plus compr√©hensible.

![Symfony-secu-new.png](https://yousign.slite.com/api/files/qJqX78Jr7G/Symfony-secu-new.png "R√©sum√© des nouveaut√©s Symfony - Source : Symfony")

Dans cet article, je vous propose de faire un tour d‚Äôhorizon de ce nouveau syst√®me et des autres nouvelles fonctionnalit√©s.

3,2,1‚Ä¶ Top √† la vachette üêÆ

## Activons le nouveau syst√®me

üí°Pour utiliser le nouveau syst√®me, il faut tout d‚Äôabord update le security.yaml comme ceci :

    # config/packages/security.yaml
    security:
        enable_authenticator_manager: true

## Qu'est ce qui change ? üìö

Le workflow d'authentification est simplifi√© : dans le nouveau syst√®me, il n‚Äôy a qu‚Äôun Listener `AuthenticatorManagerListener` qui va passer la requ√™te √† un Authenticator manager `AuthenticatorManager` fourni par Symfony ; puis l'Authenticator manager va r√©soudre les Authenticators et retourner une Response.

Voici un sch√©ma extrait [d'un article de Wouter](https://wouterj.nl/2020/04/authenticators-new-symfony-security) sur le sujet.

![image.png](https://yousign.slite.com/api/files/sOZsHphyZN/image.png "Source : Wouter J")

D√©sormais, tout est reli√© √† un seul concept et une seule interface. Le concept est celui d‚ÄôAuthenticators et l‚Äôinterface est la suivante :

`Symfony\Component\Security\Http\Authenticator\AuthenticatorInterface`

üí° L'Authenticator fonctionne de la m√™me mani√®re que Guard. Voici l'interface √† impl√©menter pour cr√©er un Authenticator :

    namespace Symfony\Component\Security\Http\Authenticator;
    
    interface AuthenticatorInterface
    {
      public function supports(Request $request): ?bool; 
        
      public function authenticate(Request $request): PassportInterface;
        
      public function createAuthenticatedToken(PassportInterface $passport, string $firewallName): TokenInterface;
        
      public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response;
        
      public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response;
    }

‚ö†Ô∏è Cette interface vient remplacer `GuardAuthenticatorInterface` qui fut introduit dans [la version Symfony 2.8](https://symfony.com/blog/new-in-symfony-2-8-guard-authentication-component) ; les m√©thodes `getUser` et `getCredentials` sont remplac√©es par une nouvelle m√©thode `authenticate()`.

Pour rappel, avec `Guards` la m√©thode `getCredentials` passait les `credentials` r√©cup√©r√©s depuis une instance de `Symfony\Component\HttpFoundation\Request` √† la m√©thode `getUser` , qui devait √† son tour retourner un `User` pour poursuivre le workflow de connexion. D√©sormais, cette t√¢che est d√©l√©gu√©e √† une m√©thode `autenticate` qui doit retourner `PassportInterface` .

`PassportInterface` est une nouvelle notion : un **Passeport** est une classe qui va contenir les informations ayant besoin d‚Äô√™tre valid√©es durant le workflow d‚Äôauthentification et ces informations seront transport√©es avec une nouvelle notion (_sinon c‚Äôest pas dr√¥le_), qui est la notion de ‚Äú**Badge**‚Äù, qui sert √† ajouter des informations au passeport pour √©tendre la s√©curit√©.

Dans le cas d‚Äôun Login soumis via un formulaire on aurait un Authenticator comme ceci :

    class LoginAuthenticator implements AuthenticatorInterface
    {
      // ...
        public function authenticate(Request $request): PassportInterface
        {
            $password = $request->request->get('password');
            $username = $request->request->get('username');
          
            return new Passport(
                new UserBadge($email), // Badge pour transporter l'user 
                new PasswordCredentials($password), // Badge pour transporter le password
                [new CsrfTokenBadge('login', $csrfToken)] // Badge pour transporter un token CSRF 
            );
        }
    } 

## Les badges en action üòé

`UserBadge` `PasswordCredentials` `CsrfTokenBadge` sont des badges qui doivent impl√©menter une interface `BadgeInterface.` . Cette interface a une m√©thode, `isResolved` , et celle-ci doit retourner `true` **pour tous les badges** pour que **l‚Äôauthentification r√©ussisse**.

## Petite explication sur qui fait quoi ‚ùì

* `UserBadge` va r√©soudre l‚Äôutilisateur via un `Provider` d√©fini dans la configuration ou un `callable` qu‚Äôon peut passer en deuxi√®me argument du constructeur. üë§
* `PasswordCredentials` va checker le password. üîê
* `CrsfTokenBadge` va checker que le token CRSF est valide. üç™
* `Passport` va se charger de transporter tout √ßa. ‚úàÔ∏è

üíù Voici le code qui boucle sur les badges pour confirmer l‚Äôauthentification :

    namespace Symfony\Component\Security\Http\Authenticator\Passport;
    
    class Passeport
    {
      // ...
       public function checkIfCompletelyResolved(): void
       {
         // Dans notre exemple $this->badges contiens UserBadge, 
         // PasswordCredentials et CsrfTokenBadge
           foreach ($this->badges as $badge) {
               if (!$badge->isResolved()) {
                    throw new BadCredentialsException(
                        sprintf('Authentication failed security badge "%s" blabla)
                    );
               }
           }
       }
    }

Ce qui est vraiment pratique, c'est que vous pouvez ajouter vous-m√™me des badges custom avec votre logique dans la m√©thode `isResolved` üëå.

## Un syst√®me plus extensible ‚ú®

La nouvelle interface `AuthenticatorInterface` modifie aussi les arguments de la m√©thode `createAuthenticatedToken.` Dans `Guards` , on avait un `UserInterface` et le `firewall` dans les param√®tres. Il √©tait donc tr√®s difficile d‚Äôajouter des informations custom au `Token` cr√©√©.

Dans le nouveau syst√®me, on r√©cup√®re le `PassportInterface` retourn√© dans la m√©thode `authenticate` , il y a donc beaucoup plus de contexte pour cr√©er notre token üéâ.

    class ApiAuthenticator implements AuthenticatorInterface
    {
        // ...
        public function authenticate(Request $request): PassportInterface
        {
            $oauthContext = "any additional context";
            $passport = new SelfValidatingPassport(new UserBadge($username), []);
            // on ajoute du context dont on peux se servir 
            // dans createAuthenticatedToken
            $passport->setAttribute('context', $oauthContext);
    
            return $passport;
        }
    
        public function createAuthenticatedToken(PassportInterface $passport, string $firewallName): TokenInterface
        {
            // r√©cup√®re le contexte
            $context = $passport->getAttribute('context');
            return new CustomOauthToken($passport->getUser(), $context);
        }
    }

üî• Si vous n'avez pas de besoins sp√©cifiques, il est inutile de cr√©er un Authenticator, Symfony met √† disposition de nombreux authenticators :

* [FormLoginAuthenticator.php](https://github.com/symfony/security-http/blob/5.x/Authenticator/FormLoginAuthenticator.php)
* [HttpBasicAuthenticator.php](https://github.com/symfony/security-http/blob/5.x/Authenticator/HttpBasicAuthenticator.php)
* [JsonLoginAuthenticator.php](https://github.com/symfony/security-http/blob/5.x/Authenticator/JsonLoginAuthenticator.php)
* ‚Ä¶

Pour les utiliser, il suffit juste de d√©clarer celui qui vous voulez :

    firewalls:
            main:
                form_login: ~ # FormLoginAuthenticator
                # OR
                http_basic: ~ # HttpBasicAuthenticato

üå† Allons jusqu'√† la version 5.2 (date d‚Äô√©criture de l‚Äôarticle pour recenser d‚Äôautres nouveaut√©s). Voici une liste non exhaustive :

* Des Events √† gogo üéÅ ([CheckPassportEvent](https://github.com/symfony/security-http/blob/5.x/Event/CheckPassportEvent.php), [LoginSuccessEvent](https://github.com/symfony/security-http/blob/5.x/Event/LoginSuccessEvent.php) , [LogoutEvent](https://github.com/symfony/security-http/blob/5.x/Event/LogoutEvent.php), [SwitchUserEvent](https://github.com/symfony/security-http/blob/5.x/Event/SwitchUserEvent.php)‚Ä¶)
* Fin de l'[Anonymous User](https://symfony.com/doc/current/security.html#firewalls-authentication) : soit l‚Äôutilisateur est authentifi√© soit non et dans ce cas il n‚Äôy a pas de token dans ‚Äúla s√©curit√©‚Äù
* Apparition de `PUBLIC_ACCESS` dans l‚Äôaccess control du `security.yaml` pour autoriser les utilisateurs non authentifi√©s l‚Äô√©quivalent du bon vieux `IS_AUTHENTICATED_ANONYMOUSLY`
* [Login Throttling](https://symfony.com/blog/new-in-symfony-5-2-login-throttling) pour limiter le nombre de tentatives de connexion
* [Login Link](https://symfony.com/doc/current/security/login_link.html) pour authentifier un utilisateur via un lien (par email‚Ä¶)
* [Accorder l‚Äôacc√®s aux utilisateurs non authentifi√© dans un Voter Custom](https://symfony.com/doc/current/security/experimental_authenticators.html#granting-anonymous-users-access-in-a-custom-voter)

Voil√† les grosses nouveaut√©s que j'ai pu relever. üòé

Merci de m'avoir lu n'h√©sitez pas √† partager l'article si celui-ci vous a plu.

> **Source** : Pour √©crire cet article je me suis appuy√© de [la documentation](https://symfony.com/doc/current/security/experimental_authenticators.html), [d'un article de Wouter](https://wouterj.nl/2020/04/authenticators-new-symfony-security), [des slides de la pr√©sentation fa√Ætes par Ryan Weaver √† la SFCon 2020](https://speakerdeck.com/weaverryan/modern-security-with-symfonys-shiny-new-security-component) et **la meilleure documentation √©tant le code.** J‚Äôai moi-m√™me explor√© ces nouveaut√©s en ouvrant le vendor √† coup de `ctrl+enter`üî¶.